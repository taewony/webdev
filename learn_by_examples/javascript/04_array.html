<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Array</title>
  </head>

  <body>
    <script>
      function doc_print(...args) {
        if (args.length === 0) {
          document.write("<br>");
        } else {
          let text = args.join("");
          document.write(text + "<br>");
        }
      }
    </script>
    <h1>Array</h1>
    <pre>
        배열은 비슷한 성격의 여러 데이터들을 한 저장소에 저장해 놓고 
        필요할 때 데이터를 꺼내서 사용할 때 생성합니다.   

        새배열
        var 이름 = new Array();
        var 이름 = [];

        배열명[0] = 값;

        값 확인하기
        배열명[1]

        배열의 개수 배열명.length
    </pre>
    <script>
      let langs = ["javascript", "python", "java"];
      console.log(langs);

      doc_print("배열의 개수: " + langs.length);
    </script>
    <h3>문자열 더하기</h3>
    <script>
      let str1 = "Hello";
      let str2 = "World";
      let result = str1 + " " + str2;
      doc_print(result);
    </script>
    <h2>join</h2>
    <pre></pre>
    <script>
      let str0 = langs.join("-");
      doc_print(str0);
    </script>
    <h2>reverse</h2>
    <pre>
        원소의 정렬를 역순 변경(원본 수정)
        배열명.reverse();
    </pre>
    <script>
      doc_print(langs);
      langs.reverse();
      doc_print(langs);
    </script>
    <h2>sort</h2>
    <pre>
        원소들을 오른차순, 내림순 정렬 (원본 수정)
        배열명.sort(); 
    </pre>
    <script>
      let fruits = ["mango", "banana", "apple", "cherry"];
      let numbers = [4, 2, 5, 1, 3];
      doc_print(fruits);
      doc_print(numbers);

      fruits.sort();
      doc_print(fruits);
      numbers.sort();
      doc_print(numbers);
    </script>
    <h2>push</h2>
    <script>
      fruits.push("orange");
      doc_print(fruits);
    </script>
    <h2>pop</h2>
    <script>
      fruits.pop();
      doc_print(fruits);
    </script>
    <h2>unshift</h2>
    <script>
      fruits.unshift("kiwi");
      doc_print(fruits);
    </script>
    <h2>shift</h2>
    <script>
      fruits.shift();
      doc_print(fruits);
    </script>
    <h2>slice</h2>
    <script>
      let sliced = fruits.slice(1, 3);
      doc_print("Sliced: " + sliced);
      doc_print("Fruits: " + fruits);
    </script>
    <h2>splice</h2>
    <script>
      newfruits = fruits.splice(1, 2);
      doc_print("New Fruits: " + newfruits);
      doc_print("Fruits: " + fruits);
    </script>
    <h2>concat</h2>
    <pre>
        원본.concat(새로운배열)
    </pre>
    <script>
      let moreFruits = ["pineapple", "mango"];
      let allFruits = fruits.concat(moreFruits);
      doc_print(allFruits);
      let langs_str = langs + ["html", "css"]; // string concat
      doc_print(langs_str);
    </script>
    <h2>filter</h2>
    <pre>
        조건에 부합하는 원소들을 추출하여 새로운 배열을 생성
    </pre>
    <script>
      let filtered = fruits.filter(function (fruit) {
        return fruit.startsWith("a");
      });
      doc_print("Filtered: " + filtered);
      let nums = [1, 2, 3, 4, 5];
      let filteredNums = nums.filter(function (num) {
        return num % 2 == 0;
      });
      doc_print("Filtered Numbers: " + filteredNums);
    </script>
    <h2>map & filter</h2>
    <pre>
        모든 요소에 연산을 취하고 난 후에 조건에 부합하는 원소들을 추출하여 새로운 배열을 생성
    </pre>
    <script>
      const users = [
        { id: 1, name: "John", age: 15 },
        { id: 2, name: "Jane", age: 30 },
        { id: 3, name: "Jack", age: 35 },
      ];
      const filteredUsers = users
        .map((user) => user.age * 2)
        .filter((age) => age > 60);
      doc_print("Filtered Users: " + filteredUsers);
      const names = users.map((user) => user.name);
      doc_print("User Names: " + names);
      const adults = users.filter((user) => user.age >= 20);
      doc_print("Adult Users: " + adults.map((user) => user.name));
    </script>
  </body>
</html>
